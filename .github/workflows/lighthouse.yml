name: Lighthouse Performance

on:
  pull_request:
    branches: [main, 11-second-template]
  push:
    branches: [main, 11-second-template]
  workflow_dispatch:

jobs:
  lighthouse:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Initialize submodules explicitly (required for standalone build)
      - name: Initialize submodules
        run: git submodule update --init --recursive

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # Build Next.js
      - name: Build Next.js
        run: npm run build
        env:
          NODE_ENV: production
          NEXT_PUBLIC_THIRDWEB_CLIENT_ID: ${{ secrets.NEXT_PUBLIC_THIRDWEB_CLIENT_ID }}

      # Verificar estructura del build
      - name: Verify build output
        run: |
          echo "ðŸ“ Checking build output structure..."
          ls -la .next/ || echo "No .next directory"
          if [ -d ".next/standalone" ]; then
            echo "âœ… Standalone build found"
            ls -la .next/standalone/
          fi
          if [ -d ".next/static" ]; then
            echo "âœ… Static assets found"
          fi

      # Detectar quÃ© mÃ©todo de start usar
      - name: Detect server start method
        id: detect-server
        run: |
          if [ -f ".next/standalone/server.js" ]; then
            echo "method=standalone" >> $GITHUB_OUTPUT
            echo "âœ… Using standalone mode"
          else
            echo "method=standard" >> $GITHUB_OUTPUT
            echo "âœ… Using standard mode (npm start)"
          fi

      # Start con STANDALONE
      - name: Start Next.js (standalone)
        if: steps.detect-server.outputs.method == 'standalone'
        run: |
          cd .next/standalone
          node server.js > ../../server.log 2>&1 &
          SERVER_PID=$!
          echo $SERVER_PID > ../../.next-server.pid
          cd ../..
          echo "ðŸš€ Server started in standalone mode (PID: $SERVER_PID)"
          sleep 2
          if ps -p $SERVER_PID > /dev/null; then
            echo "âœ… Process is running"
          else
            echo "âŒ Process died immediately! Logs:"
            cat server.log
            exit 1
          fi
        env:
          NODE_ENV: production
          NEXT_PUBLIC_API_MOCKING: "enabled"
          NEXT_PUBLIC_THIRDWEB_CLIENT_ID: ${{ secrets.NEXT_PUBLIC_THIRDWEB_CLIENT_ID }}
          PORT: 3000
          HOSTNAME: "0.0.0.0"

      # Start con NPM START
      - name: Start Next.js (standard)
        if: steps.detect-server.outputs.method == 'standard'
        run: |
          npm run start > server.log 2>&1 &
          SERVER_PID=$!
          echo $SERVER_PID > .next-server.pid
          echo "ðŸš€ Server started in standard mode (PID: $SERVER_PID)"
          sleep 2
          if ps -p $SERVER_PID > /dev/null; then
            echo "âœ… Process is running"
          else
            echo "âŒ Process died immediately! Logs:"
            cat server.log
            exit 1
          fi
        env:
          NODE_ENV: production
          NEXT_PUBLIC_API_MOCKING: "enabled"
          NEXT_PUBLIC_THIRDWEB_CLIENT_ID: ${{ secrets.NEXT_PUBLIC_THIRDWEB_CLIENT_ID }}
          PORT: 3000
      
      # Wait for server con verificaciÃ³n REAL de que funciona
      - name: Wait for server to be ready
        run: |
          echo "â³ Waiting for Next.js to be ready..."
          
          # FunciÃ³n para verificar si el servidor responde correctamente
          check_server() {
            local url=$1
            local response=$(curl -s -o /dev/null -w "%{http_code}" "$url" 2>/dev/null)
            echo $response
          }
          
          # Esperar a que el servidor responda (acepta 200, 307, 404)
          # 307 = redirect (expected con next-intl), 404 = server ready pero ruta no encontrada
          MAX_ATTEMPTS=60
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS=$(check_server "http://localhost:3000/en")
            
            if [ "$STATUS" = "200" ] || [ "$STATUS" = "307" ] || [ "$STATUS" = "404" ]; then
              echo "âœ… Server is ready (status: $STATUS) on attempt $i"
              break
            elif [ "$STATUS" = "500" ]; then
              echo "âš ï¸ Server responding but with 500 error (attempt $i/$MAX_ATTEMPTS)"
              if [ $i -ge 10 ]; then
                echo "âŒ Server keeps returning 500 errors. Showing logs:"
                tail -50 server.log
                exit 1
              fi
            else
              echo "â³ Waiting for server... (attempt $i/$MAX_ATTEMPTS, status: $STATUS)"
            fi
            
            sleep 2
            
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "âŒ Server failed to start properly. Final logs:"
              cat server.log
              exit 1
            fi
          done
          
          # Verificar locales con status code check
          echo "ðŸŒ Checking locales..."
          for LOCALE in en es ca de; do
            STATUS=$(check_server "http://localhost:3000/$LOCALE")
            if [ "$STATUS" = "200" ]; then
              echo "âœ… /$LOCALE is ready"
            else
              echo "âš ï¸ /$LOCALE returned status $STATUS"
            fi
          done
          
          echo "ðŸŽ‰ Server is ready for Lighthouse!"

      # Mostrar Ãºltimas lÃ­neas de logs antes de Lighthouse
      - name: Show server startup logs
        run: |
          echo "ðŸ“‹ Last 20 lines of server logs:"
          tail -20 server.log || echo "No logs yet"
        
      - name: Run Lighthouse CI
        run: npm run lhci:perf

      # Si Lighthouse falla, mostrar logs del servidor
      - name: Show server logs on failure
        if: failure()
        run: |
          echo "ðŸ“‹ Full server logs:"
          cat server.log || echo "No log file found"

      - name: Check performance thresholds
        run: npm run perf:check

      - name: Upload Lighthouse reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lighthouse-reports
          path: docs/lighthouse-reports/perf/
          retention-days: 30

      - name: Parse Lighthouse results
        id: lighthouse
        if: always()
        run: |
          # Parse manifest and extract scores
          MANIFEST="docs/lighthouse-reports/perf/manifest.json"
          
          if [ -f "$MANIFEST" ]; then
            # Get first report (homepage)
            REPORT_PATH=$(jq -r '.[0].jsonPath' $MANIFEST)
            
            # Extract scores (0-1 to 0-100)
            PERF=$(jq -r '.categories.performance.score * 100 | floor' $REPORT_PATH)
            ACC=$(jq -r '.categories.accessibility.score * 100 | floor' $REPORT_PATH)
            SEO=$(jq -r '.categories.seo.score * 100 | floor' $REPORT_PATH)
            BP=$(jq -r '.categories["best-practices"].score * 100 | floor' $REPORT_PATH)
            
            echo "perf_score=$PERF" >> $GITHUB_OUTPUT
            echo "acc_score=$ACC" >> $GITHUB_OUTPUT
            echo "seo_score=$SEO" >> $GITHUB_OUTPUT
            echo "bp_score=$BP" >> $GITHUB_OUTPUT
            
            # All pages summary
            echo "## Lighthouse Performance Report" > lighthouse-summary.md
            echo "" >> lighthouse-summary.md
            echo "| Page | Performance | Accessibility | SEO | Best Practices |" >> lighthouse-summary.md
            echo "|------|-------------|---------------|-----|----------------|" >> lighthouse-summary.md
            
            jq -r '.[] | .url' $MANIFEST | while read url; do
              REPORT=$(jq --arg url "$url" '.[] | select(.url == $url) | .jsonPath' $MANIFEST | tr -d '"')
              P=$(jq -r '.categories.performance.score * 100 | floor' $REPORT)
              A=$(jq -r '.categories.accessibility.score * 100 | floor' $REPORT)
              S=$(jq -r '.categories.seo.score * 100 | floor' $REPORT)
              B=$(jq -r '.categories["best-practices"].score * 100 | floor' $REPORT)
              
              echo "| $url | $P% | $A% | $S% | $B% |" >> lighthouse-summary.md
            done
            
            cat lighthouse-summary.md
          fi

      - name: Comment PR with Lighthouse results
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && always()
        with:
          script: |
            const fs = require('fs');
            
            if (!fs.existsSync('lighthouse-summary.md')) {
              console.log('No Lighthouse summary found');
              return;
            }
            
            const summary = fs.readFileSync('lighthouse-summary.md', 'utf8');
            
            const comment = `
            ${summary}
            
            ---
            
            **Thresholds:** Performance â‰¥90%, Accessibility â‰¥95%, SEO â‰¥90%, Best Practices â‰¥95%
            
            [View detailed reports in artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Lighthouse Performance Report')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment,
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment,
              });
            }

      - name: Create shields.io badge data
        if: github.ref == 'refs/heads/main' && always()
        run: |
          mkdir -p docs/badges
          
          MANIFEST="docs/lighthouse-reports/perf/manifest.json"
          if [ -f "$MANIFEST" ]; then
            # Get homepage scores
            REPORT_PATH=$(jq -r '.[0].jsonPath' $MANIFEST)
            
            PERF=$(jq -r '.categories.performance.score * 100 | floor' $REPORT_PATH)
            ACC=$(jq -r '.categories.accessibility.score * 100 | floor' $REPORT_PATH)
            SEO=$(jq -r '.categories.seo.score * 100 | floor' $REPORT_PATH)
            BP=$(jq -r '.categories["best-practices"].score * 100 | floor' $REPORT_PATH)
            
            # Create JSON for shields.io endpoint
            echo "{\"schemaVersion\": 1, \"label\": \"performance\", \"message\": \"$PERF%\", \"color\": \"brightgreen\"}" > docs/badges/perf.json
            echo "{\"schemaVersion\": 1, \"label\": \"accessibility\", \"message\": \"$ACC%\", \"color\": \"brightgreen\"}" > docs/badges/acc.json
            echo "{\"schemaVersion\": 1, \"label\": \"seo\", \"message\": \"$SEO%\", \"color\": \"brightgreen\"}" > docs/badges/seo.json
            echo "{\"schemaVersion\": 1, \"label\": \"best-practices\", \"message\": \"$BP%\", \"color\": \"brightgreen\"}" > docs/badges/bp.json
          fi

      - name: Commit badge data
        if: github.ref == 'refs/heads/main' && always()
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add docs/badges/*.json || true
          git commit -m "chore: update lighthouse badges [skip ci]" || echo "No changes to commit"
          git push || echo "No changes to push"

      # Stop server
      - name: Stop Next.js server â›”
        if: always()
        run: |
          if [ -f .next-server.pid ]; then
            PID=$(cat .next-server.pid)
            kill $PID 2>/dev/null || true
            sleep 2
            kill -9 $PID 2>/dev/null || true
            rm -f .next-server.pid
          fi
          pkill -f "next start" || true
          pkill -f "node.*server" || true